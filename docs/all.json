{"shell":true,"revision":"e32efbb11d6c090bdbc91e31f9987a1758265251","objects":[{"type":null,"source":"lib/agent_map.ex:11","object_type":"ModuleObject","moduledoc":"`AgentMap` is a `GenServer` that holds `Map` and provides concurrent access\nvia `Agent` API for operations made on different keys. Basically, it can be\nused as a cache, memoization and computational framework and, sometimes, as a\n`GenServer` replacement.\n\n`AgentMap` can be seen as a `Map`, each value of that is an `Agent`. When a\ncallback that change state (see `update/3`, `get_and_update/3`, `cast/3` and\nderivatives) comes in, special temporary process (called \"worker\") is created.\nThat process holds queue of callbacks for corresponding key. `AgentMap`\nrespects order in which callbacks arrives and supports transactions —\noperations that simultaniously change group of values.\n\nModule API is in fact a copy of the `Agent`'s and `Map`'s modules. Special\nstruct that allows to use `Enum` module and `[]` operator can be created via\n`new/1` function.\n\n## Examples\n\nLet's create an accounting.\n\n    defmodule Account do\n      use AgentMap\n\n      def start_link() do\n        AgentMap.start_link name: __MODULE__\n      end\n\n      @doc \"\"\"\n      Returns `{:ok, balance}` for account or `:error` if account\n      is unknown.\n      \"\"\"\n      def balance(account), do: AgentMap.fetch __MODULE__, account\n\n      @doc \"\"\"\n      Withdraw. Returns `{:ok, new_amount}` or `:error`.\n      \"\"\"\n      def withdraw(account, amount) do\n        AgentMap.get_and_update __MODULE__, account, fn\n          nil ->     # no such account\n            {:error} # (!) returning {:error, nil} would create key with nil value\n          balance when balance > amount ->\n            {{:ok, balance-amount}, balance-amount}\n          _ ->\n            {:error}\n        end\n      end\n\n      @doc \"\"\"\n      Deposit. Returns `{:ok, new_amount}` or `:error`.\n      \"\"\"\n      def deposit(account, amount) do\n        AgentMap.get_and_update __MODULE__, account, fn\n          nil ->\n            {:error}\n          balance ->\n            {{:ok, balance+amount}, balance+amount}\n        end\n      end\n\n      @doc \"\"\"\n      Trasfer money. Returns `:ok` or `:error`.\n      \"\"\"\n      def transfer(from, to, amount) do\n        AgentMap.get_and_update __MODULE__, fn # transaction call\n          [nil, _] -> {:error}\n          [_, nil] -> {:error}\n          [b1, b2] when b1 >= amount ->\n            {:ok, [b1-amount, b2+amount]}\n          _ -> {:error}\n        end, [from, to]\n      end\n\n      @doc \"\"\"\n      Close account. Returns `:ok` if account exists or\n      `:error` in other case.\n      \"\"\"\n      def close(account) do\n        if AgentMap.has_key? __MODULE__, account do\n          AgentMap.delete __MODULE__, account\n          :ok\n        else\n          :error\n        end\n      end\n\n      @doc \"\"\"\n      Open account. Returns `:error` if account exists or\n      `:ok` in other case.\n      \"\"\"\n      def open(account) do\n        AgentMap.get_and_update __MODULE__, account, fn\n          nil -> {:ok, 0} # set balance to 0, while returning :ok\n          _   -> {:error} # return :error, do not change balance\n        end\n      end\n    end\n\nMemoization example.\n\n    defmodule Memo do\n      use AgentMap\n\n      def start_link() do\n        AgentMap.start_link name: __MODULE__\n      end\n\n      def stop(), do: AgentMap.stop __MODULE__\n\n      @doc \"\"\"\n      If `{task, arg}` key is known — return it, else, invoke given `fun` as\n      a Task, writing result under `{task, arg}`.\n      \"\"\"\n      def calc(task, arg, fun) do\n        AgentMap.get_and_update __MODULE__, {task, arg}, fn\n          nil ->\n            res = fun.(arg)\n            {res, res}\n\n          _value ->\n            # Change nothing, return current value.\n            :id\n        end\n      end\n    end\n\n    defmodule Calc do\n      def fib(0), do: 0\n      def fib(1), do: 1\n\n      def fib(n) when n >= 0 do\n        Memo.calc(:fib, n, fn n -> fib(n - 1) + fib(n - 2) end)\n      end\n    end\n\nSimilar to `Agent`, any changing state function given to the `AgentMap`\neffectively blocks execution of any other function **on the same key** until\nthe request is fulfilled. So it's important to avoid use of expensive\noperations inside the agentmap. See corresponding `Agent` docs section.\n\nFinally note that `use AgentMap` defines a `child_spec/1` function, allowing\nthe defined module to be put under a supervision tree. The generated\n`child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification id, defauts to the current module\n  * `:start` - how to start the child process (defaults to calling `__MODULE__.start_link/1`)\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child\n\nFor example:\n\n    use AgentMap, restart: :transient, shutdown: 10_000\n\nSee the `Supervisor` docs for more information.\n\n## Name registration\n\nAn agentmap is bound to the same name registration rules as GenServers. Read\nmore about it in the `GenServer` documentation.\n\n## A word on distributed agents/agentmaps\n\nSee corresponding `Agent` module section.\n\n## Hot code swapping\n\n`AgentMap` can have its code hot swapped live by simply passing a module,\nfunction, and arguments tuple to the update instruction. For example, imagine\nyou have an `AgentMap` named `:sample` and you want to convert all its inner\nvalues from a keyword list to a map. It can be done with the following\ninstruction:\n\n    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n\n## Using `Enum` module and `[]`-access operator\n\n`%AgentMap{}` is a special struct that contains pid of the `agentmap` process\nand for that `Enumerable` protocol is implemented. So, `Enum` should work as\nexpected:\n\n    iex> AgentMap.new() |> Enum.empty?()\n    true\n    iex> AgentMap.new(key: 42) |> Enum.empty?()\n    false\n\nSimilarly, `AgentMap` follows `Access` behaviour, so `[]` operator could be\nused:\n\n    iex> AgentMap.new(a: 42, b: 24)[:a]\n    42\n\nexcept of `put_in` operator.\n","module":"Elixir.AgentMap","id":"AgentMap"},{"type":"impl","source":"lib/agent_map/enumerable.ex:1","object_type":"ModuleObject","moduledoc":null,"module":"Elixir.Enumerable.AgentMap","id":"Enumerable.AgentMap"},{"type":"defmacro","source":"lib/agent_map.ex:235","signature":[["opts",[],null]],"object_type":"FunctionObject","name":"__using__","module_id":"AgentMap","id":"__using__/1","doc":false,"arity":1},{"type":"def","source":"lib/agent_map.ex:1025","signature":[["agentmap",[],null],["key",[],null],["fun",[],null],["\\\\",[],[["opts",[],null],[]]]],"object_type":"FunctionObject","name":"cast","module_id":"AgentMap","id":"cast/4","doc":"Perform `cast` (\"fire and forget\") `update/3`. Works the same as `update/4`\nbut returns `:ok` immediately.\n","arity":4},{"type":"def","source":"lib/agent_map.ex:230","signature":[["funs_and_opts",[],null]],"object_type":"FunctionObject","name":"child_spec","module_id":"AgentMap","id":"child_spec/1","doc":false,"arity":1},{"type":"def","source":"lib/agent_map.ex:1233","signature":[["agentmap",[],null],["key",[],null]],"object_type":"FunctionObject","name":"delete","module_id":"AgentMap","id":"delete/2","doc":"Deletes the entry in `agentmap` for a specific `key`. Always returns\n`agentmap` to support chaining.\n\nSyntax sugar for `get_and_update agentmap, :!, key, fn _ -> :pop end`.\n\n## Examples\n\n    iex> mag = AgentMap.new a: 1, b: 2\n    iex> AgentMap.delete(mag, :a) |>\n    ...> AgentMap.take([:a, :b])\n    %{b: 2}\n    #\n    iex> AgentMap.delete(mag, :a) |>\n    ...> AgentMap.take([:a, :b])\n    %{b: 2}\n","arity":2},{"type":"def","source":"lib/agent_map.ex:1256","signature":[["agentmap",[],null],["keys",[],null]],"object_type":"FunctionObject","name":"drop","module_id":"AgentMap","id":"drop/2","doc":"Drops the given `keys` from `agentmap`. If `keys` contains keys that are not\nin `agentmap`, they're simply ignored.\n\nSyntax sugar for transaction call\n\n    get_and_update agentmap, :!, fn _ -> :pop end, keys\n\n## Examples\n\n    iex> AgentMap.new(a: 1, b: 2, c: 3) |>\n    ...> AgentMap.drop([:b, :d]) |>\n    ...> AgentMap.keys()\n    [:a, :c]\n","arity":2},{"type":"def","source":"lib/agent_map.ex:1115","signature":[["agentmap",[],null],["key",[],null]],"object_type":"FunctionObject","name":"fetch","module_id":"AgentMap","id":"fetch/2","doc":"Fetches the value for a specific `key` in the given `agentmap`.\n\nIf `agentmap` contains the given `key` with value value, then `{:ok, value}`\nis returned. If `map` doesn’t contain `key`, `:error` is returned.\n\nExamples\n\n    iex> mag = AgentMap.new(a: 1)\n    iex> AgentMap.fetch mag, :a\n    {:ok, 1}\n    iex> AgentMap.fetch mag, :b\n    :error\n","arity":2},{"type":"def","source":"lib/agent_map.ex:1134","signature":[["agentmap",[],null],["key",[],null]],"object_type":"FunctionObject","name":"fetch!","module_id":"AgentMap","id":"fetch!/2","doc":"Fetches the value for a specific `key` in the given `agentmap`, erroring out\nif `agentmap` doesn't contain `key`. If `agentmap` contains the given `key`,\nthe corresponding value is returned. If `agentmap` doesn't contain `key`, a\n`KeyError` exception is raised.\n\n## Examples\n\n    iex> mag = AgentMap.new a: 1\n    iex> AgentMap.fetch! mag, :a\n    1\n    iex> AgentMap.fetch! mag, :b\n    ** (KeyError) key :b not found\n","arity":2},{"type":"def","source":"lib/agent_map.ex:620","signature":[["agentmap",[],null],["key",[],null]],"object_type":"FunctionObject","name":"get","module_id":"AgentMap","id":"get/2","doc":"`get/2` call immediately returns value for the given `key`. If there is no\nsuch `key`, `nil` is returned. It is a clone of `Map.get/3` function, so as\nthe third argument, `default` value could be provided:\n\n    iex> mag = AgentMap.new a: 42\n    iex> AgentMap.get mag, :a\n    42\n    iex> AgentMap.get mag, :b\n    nil\n    iex> AgentMap.get mag, :b, :error\n    :error\n\nso it is fully compatible with `Access` behaviour. See `Access.get/3`.\n","arity":2},{"type":"def","source":"lib/agent_map.ex:567","signature":[["agentmap",[],null],["key",[],null],["default",[],null]],"object_type":"FunctionObject","name":"get","module_id":"AgentMap","id":"get/3","doc":null,"arity":3},{"type":"def","source":"lib/agent_map.ex:470","signature":[["agentmap",[],null],["key",[],null],["fun",[],null],["opts",[],null]],"object_type":"FunctionObject","name":"get","module_id":"AgentMap","id":"get/4","doc":"Takes value(s) for the given `key`(s) and invokes `fun`, passing values as the\nfirst argument and `nil`(s) for the values that are lost. If there are\ncallbacks awaiting invocation, this call will be added to the end of the\ncorresponding queues. Because the `get` calls do not change states —\n`agentmap` can and will be executed concurrently, in no more than\n`max_threads` (this could be tweaked per key, via `max_threads/2` call).\n\nAs in the case of `update`, `get_and_update` and `cast` methods, `get` call\nhas two forms:\n\n  * single key: `get(agentmap, key, fun)`, where `fun` expected only one value\n    to be passed;\n  * and multiple keys (transactions): `get(agentmap, fun, [key1, key2, …])`,\n    where `fun` expected to take a list of values.\n\nFor example, compare two calls:\n\n    AgentMap.get Account, &Enum.sum/1, [:alice, :bob]\n    AgentMap.get Account, :alice, & &1\n\n— the first one returns sum of Alice and Bob balances in one operation, while\nthe second one returns amount of money Alice has.\n\n## Options\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the `agentmap` executes the `fun` and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the caller exits. By default it's equal\nto `5000` ms. This value could be given as `:timeout` option, or separately,\nso:\n\n    AgentMap.get agentmap, :key, fun\n    AgentMap.get agentmap, :key, fun, 5000\n    AgentMap.get agentmap, :key, fun, timeout: 5000\n    AgentMap.get agentmap, :key, fun, timeout: 5000, !: false\n\nmeans the same.\n\nThe `:!` option is used to make \"urgent\" calls. Values could have an\nassociated queue of callbacks, awaiting of execution. \"Urgent\" version allows\nto retrive value immediately at the moment of call. If this option is\nprovided, `fun` will be always executed in a separate `Task`.\n\n## Examples\n\n    iex> mag = AgentMap.new()\n    iex> AgentMap.get mag, :alice, & &1\n    nil\n    iex> AgentMap.put mag, :alice, 42\n    iex> AgentMap.get mag, :alice, & &1+1\n    43\n    #\n    # aggregate calls:\n    #\n    iex> AgentMap.put mag, :bob, 43\n    iex> AgentMap.get mag, &Enum.sum/1, [:alice, :bob]\n    85\n    # order matters:\n    iex> AgentMap.get mag, {&Enum.reduce/3, [0, &-/2]}, [:alice, :bob]\n    1\n    iex> AgentMap.get mag, {&Enum.reduce/3, [0, &-/2]}, [:bob, :alice]\n    -1\n\n \"Urgent\" calls:\n\n    iex> mag = AgentMap.new key: 42\n    iex> AgentMap.cast mag, :key, fn _ ->\n    ...>   :timer.sleep(100)\n    ...>   43\n    ...> end\n    iex> (AgentMap.get mag, :key, & &1, !: true) || (IO.inspect(AgentMap.get mag, :key, & &1, !: true); :timer.sleep(10); IO.inspect(AgentMap.get mag, :key, & &1, !: true))\n    42\n    iex> mag[:key] # the same\n    42\n    iex> AgentMap.get mag, :key, & &1\n    43\n    iex> AgentMap.get mag, :key, & &1, !: true\n    43\n","arity":4},{"type":"def","source":"lib/agent_map.ex:641","signature":[["agentmap",[],null],["key",[],null],["fun",[],null],["\\\\",[],[["opts",[],null],[]]]],"object_type":"FunctionObject","name":"get_and_update","module_id":"AgentMap","id":"get_and_update/4","doc":"Updates the `agentmap` value(s) with given `key`(s) and returns result of some\ncalculation. The callback `fun` will be added to the the end of the queue for\nthen given `key` (or to the begining, if `!: true` option is given). When\ninvocation happens, `agentmap` takes value(s) for the given `key`(s) and\ninvokes `fun`, passing values as the first argument and `nil`(s) for the\nvalues that are lost.\n\nAs in the case of `get`, `update` and `cast` methods, `get_and_update` call\nhas two forms:\n\n  * single key: `get_and_update(agentmap, key, fun)`, where `fun` expected\n    only one value to be passed;\n  * and multiple keys (transactions): `get_and_update(agentmap, fun, [key1,\n    key2, …])`, where `fun` expected to take a list of values.\n\nFor example, compare two calls:\n\n    AgentMap.get_and_update Account, fn [a,b] -> {:swapped, [b,a]} end, [:alice, :bob]\n    AgentMap.get_and_update Account, :alice, & {&1, &1+1000000}\n\n— the first swapes balances of Alice and Bob balances, returning `:swapped`\natom, while the second one returns current Alice balance and deposits 1000000\ndollars.\n\nSingle key calls `fun` may return:\n\n  * a two element tuple: `{\"get\" value, new value}`;\n  * a one element tuple `{\"get\" value}`;\n  * `:id` to return current value while not changing it;\n  * `:pop`, similar to `Map.get_and_update/3` it returns value with given\n    `key` and removes it from `agentmap`.\n\n  * `{:chain, {key, fun}, new_value}` — to not return value, but initiate\n    another `get_and_update/4` with given `key` and `fun` pair;\n  * `{:chain, {fun, keys}, new_value}` — to not return value, but initiate\n    transaction call `get_and_update/4` with given `fun` and `keys` pair.\n\nWhile in transaction (group/multiple keys) calls `fun` may return:\n\n  * a two element tuple `{\"get\" value, [new values]}`;\n  * a two element tuple `{\"get\" value, :drop}` — to remove values with given\n    keys;\n  * a two element tuple `{\"get\" value, :id}` — to return \"get\" value while not\n    changin values;\n\n  * a one element tuple `{\"get\" value}`, that is the same as `{\"get\" value,\n    :id}`;\n\n  * a list with values `[{\"get\" value} or {\"get\" value, new value} or :id or\n    :pop]`. This returns a list of values as it was made a group of single key\n    calls;\n\n  * `:id` to return values while not changing it;\n  * `:pop` to return values while with given `keys` while removing them from\n    `agentmap`';\n\n  * `{:chain, {key, fun}, new_value}` — to not return value, but initiate\n    another `get_and_update/4` with given `key` and `fun` pair;\n  * `{:chain, {fun, keys}, new_value}` — to not return value, but initiate\n    transaction call `get_and_update/4` with given `fun` and `keys` pair.\n\nAll lists returned by transaction call should have length equal to the number\nof keys given.\n\nFor ex.:\n\n    get_and_update agentmap, fn [a, b] ->\n      if a > 10 do\n        a = a-10\n        b = b+10\n        [{a,a}, {b,b}] # [{get, new_state}]\n      else\n        {{:error, \"Alice does not have 10$ to give to Bob!\"}, [a,b]} # {get, [new_state]}\n      end\n    end, [:alice, :bob]\n\nor:\n\n    iex> mag = AgentMap.new alice: 42, bob: 24\n    iex> AgentMap.get_and_update mag, fn _ -> [:pop, :id] end, [:alice, :bob]\n    [42, 24]\n    iex> AgentMap.get mag, & &1, [:alice, :bob]\n    [nil, 24]\n\n(!) State changing transaction (such as `get_and_update`) will block value the\nsame way as a single key calls. For ex.:\n\n    iex> AgentMap.new(alice: 42, bob: 24, chris: 0) |>\n    ...> AgentMap.get_and_update(&:timer.sleep(1000) && {:slept_well, &1}, [:alice, :bob])\n    :slept_well\n\nwill block the possibility to `get_and_update`, `update`, `cast` and even\nnon-urgent `get` on `:alice` and `:bob` keys for 1 sec. Nonetheless values are\nalways available for \"urgent\" `get` calls and value under the key `:chris` is\nnot blocked.\n\nTransactions are *Isolated* and *Durabled* (see, ACID model). *Atomicity* can\nbe implemented inside callbacks and *Consistency* is out of question here as\nits the application level concept.\n\n## Options\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the `agentmap` executes the `fun` and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the caller exits. By default it's equal\nto `5000` ms. This value could be given as `:timeout` option, or separately,\nso:\n\n    AgentMap.get_and_update agentmap, :key, fun\n    AgentMap.get_and_update agentmap, :key, fun, 5000\n    AgentMap.get_and_update agentmap, :key, fun, timeout: 5000\n    AgentMap.get_and_update agentmap, :key, fun, timeout: 5000, !: false\n\nmeans the same.\n\nThe `:!` option is used to make \"urgent\" calls. Values could have an\nassociated queue of callbacks, awaiting of execution. If such queue exists,\n\"urgent\" version will add call to the begining of the queue (via \"selective\nreceive\").\n\nBe aware that: (1) anonymous function, `{fun, args}` or MFA tuple can be\npassed as a callback; (2) every value has it's own FIFO queue of callbacks\nwaiting to be executed and all the queues are processed concurrently; (3) no\nvalue changing calls (`get_and_update`, `update` or `cast`) could be executed\nin parallel on the same value. This can be done only for `get` calls (also,\nsee `max_threads/3`).\n\n## Examples\n\n    iex> import AgentMap\n    iex> mag = new uno: 22\n    iex> get_and_update mag, :uno, & {&1, &1 + 1}\n    22\n    iex> get mag, :uno\n    23\n    iex> get_and_update mag, :uno, fn _ -> :pop end\n    23\n    iex> has_key? mag, :uno\n    false\n    iex> get_and_update mag, :uno, fn _ -> :id end\n    nil\n    iex> has_key? mag, :uno\n    false\n    iex> get_and_update mag, :uno, fn v -> {v,v} end\n    nil\n    iex> has_key? mag, :uno\n    true\n\nTransactions:\n\n    iex> import AgentMap\n    iex> mag = new uno: 22, dos: 24\n    iex> get_and_update mag, fn [u, d] ->\n    ...>   [{u, d}, {d, u}]\n    ...> end, [:uno, :dos]\n    [22, 24]\n    iex> get mag, & &1, [:uno, :dos]\n    [24, 22]\n    #\n    iex> get_and_update mag, fn _ -> :pop end, [:dos]\n    [22]\n    iex> has_key? mag, :dos\n    false\n    #\n    iex> get_and_update mag, :dos, fn _ -> {:get} end\n    :get\n    iex> has_key? mag, :dos\n    false\n    #\n    iex> put mag, :tres, 42\n    iex> put mag, :cuatro, 44\n    iex> get_and_update mag, fn _ ->\n    ...>   [:id, {nil, :_}, {:_, nil}, :pop]\n    ...> end, [:uno, :dos, :tres, :cuatro]\n    [24, nil, :_, 44]\n    iex> get mag, & &1, [:uno, :dos, :tres, :cuatro]\n    [24, :_, nil, nil]\n\nChain calls (used rarely):\n\n    iex> import AgentMap\n    iex> mag = new uno: 24, dos: 33, tres: 42\n    iex> call = {:dos, fn _ -> {:get, :dos} end}\n    iex> get_and_update mag, :uno, fn _ ->\n    ...>   {:chain, call, :uno}\n    ...> end\n    :get\n    iex> get mag, & &1, [:uno, :dos]\n    [:uno, :dos]\n    #\n    # transaction chain calls:\n    #\n    iex> call = {fn _ -> {:get, [2,3]} end, [:dos, :tres]}\n    iex> get_and_update mag, :uno, fn _ ->\n    ...>   {:chain, call, 1}\n    ...> end\n    :get\n    iex> get mag, & &1, [:uno, :dos, :tres]\n    [1, 2, 3]\n    #\n    iex> call = {:uno, fn _ -> {:get, :u} end}\n    iex> get_and_update mag, fn _ ->\n    ...>   {:chain, call, [:d, :t]}\n    ...> end, [:dos, :tres]\n    :get\n    iex> get mag, & &1, [:uno, :dos, :tres]\n    [:u, :d, :t]\n","arity":4},{"type":"def","source":"lib/agent_map.ex:591","signature":[["agentmap",[],null],["key",[],null],["fun",[],null]],"object_type":"FunctionObject","name":"get_lazy","module_id":"AgentMap","id":"get_lazy/3","doc":"Gets the value for a specific `key` in `agentmap`.\n\nIf `key` is present in `agentmap` with value `value`, then `value` is\nreturned. Otherwise, `fun` is evaluated and its result is returned. This is\nuseful if the default value is very expensive to calculate or generally\ndifficult to setup and teardown again.\n\n## Examples\n\n    iex> mag = AgentMap.new a: 1\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> AgentMap.get_lazy mag, :a, fun\n    1\n    iex> AgentMap.get_lazy mag, :b, fun\n    13\n\n","arity":3},{"type":"def","source":"lib/agent_map.ex:1156","signature":[["agentmap",[],null],["key",[],null]],"object_type":"FunctionObject","name":"has_key?","module_id":"AgentMap","id":"has_key?/2","doc":"Returns whether the given `key` exists in the given `agentmap`.\n\n## Examples\n\n    iex> mag = AgentMap.new(a: 1)\n    iex> AgentMap.has_key?(mag, :a)\n    true\n    iex> AgentMap.has_key?(mag, :b)\n    false\n","arity":2},{"type":"def","source":"lib/agent_map.ex:1277","signature":[["agentmap",[],null]],"object_type":"FunctionObject","name":"keys","module_id":"AgentMap","id":"keys/1","doc":"Returns all keys from `agentmap`.\n\n## Examples\n\niex> AgentMap.new(a: 1, b: 2, c: 3) |>\n...> AgentMap.keys()\n[:a, :b, :c]\n","arity":1},{"type":"def","source":"lib/agent_map.ex:1042","signature":[["agentmap",[],null],["key",[],null],["value",[],null]],"object_type":"FunctionObject","name":"max_threads","module_id":"AgentMap","id":"max_threads/3","doc":"Sets the `:max_threads` value for the given `key`. Returns the old value.\n\n`agentmap` can execute `get` calls on the same key concurrently. `max_threads`\noption specifies number of threads per key used, minus one thread for the\nprocess holding the queue. By default five `get` calls on the same state could\nbe executed, so\n\n    iex> sleep100ms = fn _ ->\n    ...>   :timer.sleep 100\n    ...> end\n    iex> mag = AgentMap.new key: 42\n    iex> for _ <- 1..4, do: spawn fn ->\n    ...>   AgentMap.get mag, :key, sleep100ms\n    ...> end\n    iex> AgentMap.get mag, :key, sleep100ms\n    :ok\n\nwill be executed in around of 100 ms, not 500. Be aware, that this call:\n\n    iex> sleep100ms = fn _ ->\n    ...>   :timer.sleep 100\n    ...> end\n    iex> mag = AgentMap.new key: 42\n    iex> AgentMap.get mag, :key, sleep100ms\n    iex> AgentMap.cast mag, :key, sleep100ms\n    iex> AgentMap.cast mag, :key, sleep100ms\n    :ok\n\nwill be executed in around of 200 ms because `agentmap` can parallelize any\nsequence of `get/3` calls ending with `get_and_update/3`, `update/3` or\n`cast/3`.\n\nUse `max_threads: 1` to execute `get` calls in sequence.\n\n## Examples\n\n    iex> mag = AgentMap.new()\n    iex> AgentMap.max_threads mag, :a, 42\n    5\n    iex> AgentMap.max_threads mag, :a, :infinity\n    42\n","arity":3},{"type":"def","source":"lib/agent_map.ex:272","signature":[],"object_type":"FunctionObject","name":"new","module_id":"AgentMap","id":"new/0","doc":"Returns a new empty `agentmap`.\n\n## Examples\n\n    iex> mag = AgentMap.new()\n    iex> Enum.empty? mag\n    true\n","arity":0},{"type":"def","source":"lib/agent_map.ex:284","signature":[["enumerable",[],null]],"object_type":"FunctionObject","name":"new","module_id":"AgentMap","id":"new/1","doc":"Starts an `AgentMap` via `start_link/1` function. `new/1` returns `AgentMap`\n**struct** that contains pid of the `AgentMap`.\n\nAs the only argument, states keyword can be provided or already started\nagentmap.\n\n## Examples\n\n    iex> mag = AgentMap.new a: 42, b: 24\n    iex> mag[:a]\n    42\n    iex> AgentMap.keys mag\n    [:a, :b]\n\n    iex> {:ok, pid} = AgentMap.start_link()\n    iex> mag = AgentMap.new pid\n    iex> AgentMap.put mag, :a, 1\n    iex> mag[:a]\n    1\n","arity":1},{"type":"def","source":"lib/agent_map.ex:324","signature":[["enumerable",[],null],["transform",[],null]],"object_type":"FunctionObject","name":"new","module_id":"AgentMap","id":"new/2","doc":"Creates an agentmap from an `enumerable` via the given transformation\nfunction. Duplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> mag = AgentMap.new [:a, :b], fn x -> {x, x} end\n    iex> AgentMap.take mag, [:a, :b]\n    %{a: :a, b: :b}\n","arity":2},{"type":"def","source":"lib/agent_map.ex:1172","signature":[["agentmap",[],null],["key",[],null],["\\\\",[],[["default",[],null],null]]],"object_type":"FunctionObject","name":"pop","module_id":"AgentMap","id":"pop/3","doc":"Returns and removes the value associated with `key` in `agentmap`. If `key` is\npresent in `agentmap` with value `value`, `{value, agentmap}` is returned\nwhere `agentmap` is the same agentmap. State with given `key` is returned from\n`agentmap`. If `key` is not present in `agentmap`, `{default, agentmap}` is\nreturned.\n\nPair with agentmap is returned for compatibility with Access protocol, as it\nhave `Access.pop/2` callback.\n\n## Examples\n    iex> mag = AgentMap.new a: 1\n    iex> AgentMap.pop mag, :a\n    1\n    iex> AgentMap.pop mag, :a\n    nil\n    iex> AgentMap.pop mag, :b\n    nil\n    iex> AgentMap.pop mag, :b, :error\n    :error\n    iex> Enum.empty? mag\n    true\n","arity":3},{"type":"def","source":"lib/agent_map.ex:1200","signature":[["agentmap",[],null],["key",[],null],["value",[],null]],"object_type":"FunctionObject","name":"put","module_id":"AgentMap","id":"put/3","doc":"Puts the given `value` under `key` in `agentmap`.\n\n## Examples\n    iex> mag = AgentMap.new a: 1\n    iex> AgentMap.put(mag, :b, 2) |>\n    ...> AgentMap.take([:a, :b])\n    %{a: 1, b: 2}\n    iex> AgentMap.put(mag, :a, 3) |>\n    ...> AgentMap.take([:a, :b])\n    %{a: 3, b: 2}\n","arity":3},{"type":"def","source":"lib/agent_map.ex:1307","signature":[["agentmap",[],null],["key",[],null]],"object_type":"FunctionObject","name":"queue_len","module_id":"AgentMap","id":"queue_len/2","doc":"Length of the queue for `key`.\n\n## Examples\n\niex> mag = AgentMap.new a: 1, b: 2\niex> AgentMap.queue_len mag, :a\n0\niex> AgentMap.cast mag, :a, fn _ -> :timer.sleep(100) end\niex> AgentMap.cast mag, :a, fn _ -> :timer.sleep(100) end\niex> AgentMap.queue_len mag, :a\n2\niex> AgentMap.queue_len mag, :b\n0\n","arity":2},{"type":"def","source":"lib/agent_map.ex:1090","signature":[["agentmap",[],null],["key",[],null],["value",[],null]],"object_type":"FunctionObject","name":"replace!","module_id":"AgentMap","id":"replace!/3","doc":"Alters the value stored under `key` to `value`, but only\nif the entry `key` already exists in `map`.\n\nIf `key` is not present in `map`, a `KeyError` exception is raised.\n\n## Examples\n\n    iex> mag = AgentMap.new a: 1, b: 2\n    iex> AgentMap.replace! mag, :a, 3\n    iex> AgentMap.take mag, [:a, :b]\n    %{a: 3, b: 2}\n    iex> AgentMap.replace! mag, :c, 3\n    ** (KeyError) key :c not found\n","arity":3},{"type":"def","source":"lib/agent_map.ex:410","signature":[["\\\\",[],[["funs_and_opts",[],null],[["timeout",5000]]]]],"object_type":"FunctionObject","name":"start","module_id":"AgentMap","id":"start/1","doc":"Starts an `AgentMap` as unlinked process.\n\nSee `start_link/2` for details.\n\n## Examples\n\n    iex> AgentMap.start one: 42,\n    ...>                two: fn -> :timer.sleep(150) end,\n    ...>                three: fn -> :timer.sleep(:infinity) end,\n    ...>                timeout: 100\n    {:error, [one: :badfun, two: :timeout, three: :timeout]}\n\n    iex> AgentMap.start one: :foo,\n    ...>                one: :bar,\n    ...>                three: fn -> :timer.sleep(:infinity) end,\n    ...>                timeout: 100\n    {:error, [one: :exists]}\n\n    iex> err = AgentMap.start one: 76,\n    ...>                      two: fn -> raise \"oops\"\n    ...>       end\n    iex> {:error, [one: :badfun, two: {exception, _stacktrace}]} = err\n    iex> exception\n    %RuntimeError{message: \"oops\"}\n","arity":1},{"type":"def","source":"lib/agent_map.ex:339","signature":[["\\\\",[],[["funs_and_opts",[],null],[["timeout",5000]]]]],"object_type":"FunctionObject","name":"start_link","module_id":"AgentMap","id":"start_link/1","doc":"Starts an agentmap linked to the current process with the given function. This\nis often used to start the agentmap as a part of a supervision tree.\n\nThe only argument is a keyword, elements of which is `GenServer.options` or\npairs `{term, a_fun(any)}`, where `a_fun(any)` is a zero arity anonymous fun,\npair `{fun, args}` or corresponding MFA-tuple.\n\nFor each key, callback is executed as a separate `Task`.\n\n## Options\n\nThe `:name` option is used for registration as described in the module\ndocumentation.\n\nIf the `:timeout` option is present, the agentmap is allowed to spend at most\nthe given number of milliseconds on the whole process of initialization or it\nwill be terminated and the start function will return `{:error, :timeout}`.\n\nIf the `:debug` option is present, the corresponding function in the [`:sys`\nmodule](http://www.erlang.org/doc/man/sys.html) will be invoked.\n\nIf the `:spawn_opt` option is present, its value will be passed as options to\nthe underlying process as in `Process.spawn/4`.\n\n## Return values\n\nIf the server is successfully created and initialized, the function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If a agentmap with the\nspecified name already exists, the function returns `{:error,\n{:already_started, pid}}` with the PID of that process.\n\nIf one of the callbacks fails, the function returns `{:error, [{key,\ninit_error_reason}]}`, where `init_error_reason` is `:timeout`, `:badfun`,\n`:badarity` `:exists` or an arbitrary exception. Callback must be given in\nform of anonymous function, `{fun, args}` or MFA-tuple, or else `:badfun`\nwould be returned. So you can write:\n\n    iex> import AgentMap\n    iex> {:ok,_pid} = start_link key: fn -> Enum.empty? [:v] end\n    iex> {:ok,_} = start_link k: {&Enum.empty?/1, [[:v]]}\n    iex> {:ok,_} = start_link k: {Enum, :empty?, [[:v]]}\n    iex> {:ok,_} = start_link k: {fn -> Enum.empty? [:v] end, []}\n    iex> match?({:ok,_}, start_link k: {& &1+1, [42]})\n    true\n\nBut it's easy to get `{:error, :badfun}` or `{:error, :badarity}`:\n\n    iex> AgentMap.start key: 42\n    {:error, [key: :badfun]}\n    iex> AgentMap.start key: {fn -> Enum.empty? [] end, [:extraarg]}\n    {:error, [key: :badarity]}\n    # … and so on\n\n## Examples\n\n    iex> {:ok, pid} = AgentMap.start_link key: fn -> 42 end\n    iex> AgentMap.get pid, :key, & &1\n    42\n    iex> AgentMap.get pid, :nosuchkey, & &1\n    nil\n","arity":1},{"type":"def","source":"lib/agent_map.ex:1327","signature":[["agentmap",[],null],["\\\\",[],[["reason",[],null],"normal"]],["\\\\",[],[["timeout",[],null],"infinity"]]],"object_type":"FunctionObject","name":"stop","module_id":"AgentMap","id":"stop/3","doc":"Synchronously stops the `agentmap` with the given `reason`.\n\nIt returns `:ok` if the `agentmap` terminates with the given reason. If the\nagentmap terminates with another reason, the call will exit.\n\nThis function keeps OTP semantics regarding error reporting. If the reason is\nany other than `:normal`, `:shutdown` or `{:shutdown, _}`, an error report\nwill be logged.\n\n## Examples\n\niex> {:ok, pid} = AgentMap.start_link()\niex> AgentMap.stop pid\n:ok\n","arity":3},{"type":"def","source":"lib/agent_map.ex:1218","signature":[["agentmap",[],null],["keys",[],null]],"object_type":"FunctionObject","name":"take","module_id":"AgentMap","id":"take/2","doc":"Returns a `Map` with all the key-value pairs in `agentmap` where the key is in\n`keys`. If `keys` contains keys that are not in `agentmap`, they're simply\nignored.\n\n## Examples\n    iex> AgentMap.new(a: 1, b: 2, c: 3) |>\n    ...> AgentMap.take([:a, :c, :e])\n    %{a: 1, c: 3}\n","arity":2},{"type":"def","source":"lib/agent_map.ex:894","signature":[["agentmap",[],null],["key",[],null],["fun",[],null],["\\\\",[],[["opts",[],null],[]]]],"object_type":"FunctionObject","name":"update","module_id":"AgentMap","id":"update/4","doc":"Updates the `agentmap` value(s) with given `key`(s) and return `:ok`. The\ncallback `fun` will be added to the the end of the queue for then given `key`\n(or to the begining, if `!: true` option is given). When invocation happens,\n`agentmap` takes value(s) for the given `key`(s) and invokes `fun`, passing\nvalues as the first argument and `nil`(s) for the values that are lost.\n\nAs in the case of `get`, `get_and_update` and `cast` methods, `get_and_update`\ncall has two forms:\n\n  * single key: `update(agentmap, key, fun)`, where `fun` expected only one\n    value to be passed;\n  * and multiple keys (transactions): `update(agentmap, fun, [key1, key2,\n    …])`, where `fun` expected to take a list of values.\n\nFor example, compare two calls:\n\n    AgentMap.update Account, fn [a,b] -> [b,a] end, [:alice, :bob]\n    AgentMap.update Account, :alice, & &1+1000000\n\n— the first swapes balances of Alice and Bob balances, while the second one\ndeposits 1000000 dollars to Alices balance.\n\nSingle key calls `fun` must return a new value, while transaction\n(group/multiple keys) call `fun` may return:\n\n  * a list of new values that has a length equal to the number of keys given;\n  * `:id` to not change values;\n  * `:drop` to delete corresponding values from `agentmap`.\n\nFor ex.:\n\n    iex> mag = AgentMap.new alice: 42, bob: 24, chris: 33, dunya: 51\n    iex> AgentMap.update mag, &Enum.reverse/1, [:alice, :bob]\n    :ok\n    iex> AgentMap.get mag, & &1, [:alice, :bob]\n    [24, 42]\n    iex> AgentMap.update mag, fn _ -> :drop end, [:alice, :bob]\n    iex> AgentMap.keys mag\n    [:chris, :dunya]\n    iex> AgentMap.update mag, fn _ -> :drop end, [:chris]\n    iex> AgentMap.update mag, :dunya, fn _ -> :drop end\n    iex> AgentMap.get mag, & &1, [:chris, :dunya]\n    [nil, :drop]\n\n(!) State changing transaction (such as `get_and_update`) will block value the\nsame way as a single key calls. For ex.:\n\n    iex> AgentMap.new(alice: 42, bob: 24, chris: 0) |>\n    ...> AgentMap.update(fn _ ->\n    ...>   :timer.sleep(1000)\n    ...>   :drop\n    ...> end, [:alice, :bob])\n    :ok\n\nwill block the possibility to `get_and_update`, `update`, `cast` and even\nnon-urgent `get` on `:alice` and `:bob` keys for 1 sec. Nonetheless values are\nalways available for \"urgent\" `get` calls and value under the key `:chris` is\nnot blocked.\n\nTransactions are *Isolated* and *Durabled* (see, ACID model). *Atomicity* can\nbe implemented inside callbacks and *Consistency* is out of question here as\nits the application level concept.\n\n## Options\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the `agentmap` executes the `fun` and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the caller exits. By default it's equal\nto `5000` ms. This value could be given as `:timeout` option, or separately,\nso:\n\n    AgentMap.get_and_update agentmap, :key, fun\n    AgentMap.get_and_update agentmap, :key, fun, 5000\n    AgentMap.get_and_update agentmap, :key, fun, timeout: 5000\n    AgentMap.get_and_update agentmap, :key, fun, timeout: 5000, !: false\n\nmeans the same.\n\nThe `:!` option is used to make \"urgent\" calls. Values could have an\nassociated queue of callbacks, awaiting of execution. If such queue exists,\n\"urgent\" version will add call to the begining of the queue (selective receive\nused).\n\nBe aware that: (1) this function always returns `:ok`; (2) anonymous function,\n`{fun, args}` or MFA tuple can be passed as a callback; (3) every value has\nit's own FIFO queue of callbacks waiting to be executed and all the queues are\nprocessed concurrently; (3) no value changing calls (`get_and_update`,\n`update` or `cast`) could be executed in parallel on the same value. This can\nbe done only for `get` calls (also, see `max_threads/3`).\n\nUpdates the `agentmap` value(s) with given `key`(s).\n\nUpdates agentmap state with given key. The callback `fun` will be sent to\nthe `agentmap`, which will add it to the execution queue for the given key\nstate. Before the invocation, the agentmap state will be passed as the first\nargument. If `agentmap` has no state with such key, `nil` will be passed to\n`fun`. The return value of callback becomes the new state of the agentmap.\n\n## Examples\n\n    iex> {:ok, pid} = AgentMap.start_link key: fn -> 42 end\n    iex> AgentMap.update pid, :key, & &1+1\n    :ok\n    iex> AgentMap.get pid, :key, & &1\n    43\n    #\n    iex> AgentMap.update pid, :otherkey, fn nil -> 42 end\n    :ok\n    iex> AgentMap.get pid, :otherkey, & &1\n    42\n","arity":4},{"type":"def","source":"lib/agent_map.ex:1291","signature":[["agentmap",[],null]],"object_type":"FunctionObject","name":"values","module_id":"AgentMap","id":"values/1","doc":"Returns all values from `agentmap`.\n\n## Examples\n\niex> AgentMap.new(a: 1, b: 2, c: 3) |>\n...> AgentMap.values()\n[1, 2, 3]\n","arity":1},{"type":"def","source":"lib/agent_map/enumerable.ex:1","signature":[["atom",[],"Elixir"]],"object_type":"FunctionObject","name":"__impl__","module_id":"Enumerable.AgentMap","id":"__impl__/1","doc":false,"arity":1},{"type":"def","source":"lib/agent_map/enumerable.ex:4","signature":[["agent_map",[],"Elixir"]],"object_type":"FunctionObject","name":"count","module_id":"Enumerable.AgentMap","id":"count/1","doc":null,"arity":1},{"type":"def","source":"lib/agent_map/enumerable.ex:8","signature":[["mag",[],null],["arg",[],"Elixir"]],"object_type":"FunctionObject","name":"member?","module_id":"Enumerable.AgentMap","id":"member?/2","doc":null,"arity":2},{"type":"def","source":"lib/agent_map/enumerable.ex:20","signature":[["mag",[],null],["acc",[],null],["fun",[],null]],"object_type":"FunctionObject","name":"reduce","module_id":"Enumerable.AgentMap","id":"reduce/3","doc":null,"arity":3},{"type":"def","source":"lib/agent_map/enumerable.ex:15","signature":[["mag",[],null]],"object_type":"FunctionObject","name":"slice","module_id":"Enumerable.AgentMap","id":"slice/1","doc":null,"arity":1}],"language":"elixir","git_repo_url":"git@gitlab.com:flomop/agent_map.git","client_version":"0.5.6","client_name":"inch_ex","branch_name":"master","args":[]}